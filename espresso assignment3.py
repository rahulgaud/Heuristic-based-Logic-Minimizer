# -*- coding: utf-8 -*-
"""
Created on Tue Nov 30 14:32:17 2021

@author: Lenovo
"""

""" 
Assignment 3 submitted by

            Aashish Pandia 203196001
            Prasad Trimukhe 203076001
            Rahul Gaud 203070029
            
the function and the off set should be given minterms form; the final answer 
is generated by espresso where ':' after a literal repersents its uncomplimented form
and an "'" after a literal repersents literal in complimented form.
"""


from operator import itemgetter


function = " a'b'c' + a:b'c' + a'b:c' + a'b'c: "
unique = []
for i in function :
    if i == "'" or i == "+" or i == ":" or i == ' ':
        pass
    else:
        if i not in unique:
            unique.append(i)
            
# print(unique)
indices = [i for i in range(len(unique))]
literals = dict(zip(indices,unique))

fn_implicants = function.split("+")
for j,i in enumerate (fn_implicants):
    fn_implicants[j] = i.strip()

indices = [i for i in range(len(fn_implicants))]
fn_dict =  dict(zip(indices,fn_implicants))
# print(literals[1])
'''function here'''
fn_matrix = [[0b11 for cols in unique]for rows in fn_implicants ] 

fn_change_matrix = fn_matrix.copy() 

for index1,j in enumerate(fn_implicants) :
    print("\n",j,"--")
    for index2,letter in enumerate (j):
        if letter in literals.values():
            for indx,val in literals.items():
                if val == letter:
                    index = indx 
            if j[index2 +1] == "'" : fn_matrix[index1][index] = 0b10
            if j[index2 +1] == ":" : fn_matrix[index1][index] = 0b01

'''till here '''


'''cofactor canculation'''
a_bar = [1,3]
inverted_a_bar = [ 3 - _ for _ in a_bar]
new_mat = []
k = 0

for i in fn_matrix:
    new_mat.append([])
    for j,row in zip(i, a_bar):
        print(j,type(j),row,type(row))
        new_mat[k].append(j & row)
    k += 1

k=0
new_mat_1 = []
for matrix_line in new_mat:
    if 0 in matrix_line:
        print("void")
    else:
        print("complimenting and ORing here")
        new_mat_1.append([])
        for j,row in zip(matrix_line, inverted_a_bar):
            # print(j,type(j),row,type(row))
            new_mat_1[k].append(j | row)
        k += 1
'''co ends'''

def expand_weight_matrix(in_matrix):
    # in matrix is the function matrix
    in_colomn_sum = []
    for j in range(len(in_matrix[0])):
        _ = 0
        for i in range(len(in_matrix)):
            _ += in_matrix[i][j]
        in_colomn_sum.append(_)
    _ = 0
    weight_matrix = []
    for implcnt in in_matrix:
        for num1, num2 in zip( in_colomn_sum, implcnt):
            _ = num1 * num2
        weight_matrix.append(_)
    
    weighted_function = [[i,j] for i , j in zip(weight_matrix, in_matrix)]
    weighted_function = sorted(weighted_function, reverse = True, key=itemgetter(0))
    print(weighted_function)
    return_fn = [i[1] for i in weighted_function ]
    return return_fn

def reduce_weight_matrix(in_matrix):
    # in matrix is the function matrix
    in_colomn_sum = []
    for j in range(len(in_matrix[0])):
        _ = 0
        for i in range(len(in_matrix)):
            _ += in_matrix[i][j]
        in_colomn_sum.append(_)
    _ = 0
    weight_matrix = []
    for implcnt in in_matrix:
        for num1, num2 in zip( in_colomn_sum, implcnt):
            _ = num1 * num2
        weight_matrix.append(_)
    
    weighted_function = [[i,j] for i , j in zip(weight_matrix, in_matrix)]
    weighted_function = sorted(weighted_function, key=itemgetter(0))
    return_fn = [i[1] for i in weighted_function ]
    return return_fn

OFF_set = [[1,3,1],[3,1,1]]

expand_order = expand_weight_matrix(fn_matrix)
reduce_order = reduce_weight_matrix(fn_matrix)



def expantion(implicant_list):
    return_list = implicant_list.copy()
    flag = 0
    for indx,literal in enumerate(implicant_list):
        if literal == 3:
            continue
        if literal != 3:
            save_literal = literal
            return_list[indx] = 3
            k = 0
            temp_matrix = []
            for off in OFF_set:
                temp_matrix.append([])
                for num1, num2 in zip(return_list,off):
                    temp_matrix[k].append(num1 & num2)
                k += 1
            print(temp_matrix)
        for line in temp_matrix:
            if 0 not in line:
                flag = 1
        if not flag:
            return_list[indx] = 3
            flag = 0
        else:
            return_list[indx] = save_literal
            print("cant be expanded further")
        
        return return_list
    

def irredundent():
    print("checking and removing redunduncy")


def containment_check(func_sub_list, implicant_list):
    inter_matrix = []
    check_matrix = []
    k = 0
    if type(func_sub_list[0]) == list:
        for i in func_sub_list:
            inter_matrix.append([])
            for j,row in zip(i, implicant_list):
                inter_matrix[k].append(j & row)
            k += 1
    else:
        for j,row in zip(func_sub_list, implicant_list):
                inter_matrix.append(j & row)

    inverted_implicant = [ 3 - _ for _ in implicant_list]
    k = 0
    if type(inter_matrix[0]) == list : 
        for i in inter_matrix:
            check_matrix.append([])
            for j,row in zip(i, inverted_implicant):
                check_matrix[k].append(j | row)
            k += 1
    else: 
            for j,row in zip(inter_matrix, inverted_implicant):
                check_matrix.append(j | row)        
        
    if type(check_matrix[0]) == list : 
        for row in check_matrix:
            if 3*len(row) == sum(row):
                
                print("tautology")
                return True
        
        all_zero_flag = 1
        for coloumn in range(len(check_matrix[0])):
            for row in check_matrix:
                if row[coloumn] != 2:
                    all_zero_flag = 0
                    
        all_ones_flag = 1
        for coloumn in range(len(check_matrix[0])):
            for row in check_matrix:
                if row[coloumn] != 1:
                    all_ones_flag = 0                
        
        if all_zero_flag or all_ones_flag :
            print ("not tautology")
            return False
    
        # all_threes_flag = 0
        dependent_col = []
        for coloumn in range(len(check_matrix[0])):
            for row in check_matrix:
                if row[coloumn] != 3:
                    dependent_col.append(coloumn)
                    # all_ones_flag = 0    
        
        
        if len(set(dependent_col)) == 1 :
            coloumn_to_check = dependent_col[0]
            all_zero_flag = 1
            all_ones_flag = 1
            for row in check_matrix:
                if row[coloumn_to_check] != 2:
                    all_zero_flag = 0
                if row[coloumn] != 1:
                    all_ones_flag = 0                
                        
            if not all_zero_flag and not all_ones_flag :
                print (" tautology")
                return True
        else: return False
    else:
        if 3*len(check_matrix) == sum(check_matrix):
                print("tautology")
                return True
        else:
            print("not tautology")
            return False          

def expantion_redunduncy_removal():
    global fn_matrix,expand_order;
    for indx,line in enumerate(expand_order):
        if line != expand_order[-1]:
            if containment_check(expand_order[-1], line ):
                expand_order.pop(indx)
                
        
    
    
def expand():
    global expand_order
    for i in range (2):
        expand_order[-1] = expantion(expand_order[-1])
        expantion_redunduncy_removal()
        if i != 1 : expand_order = expand_weight_matrix(expand_order)



def reduce(in_list):
    global fn_matrix
    # in_list is sorted for reduction
    return_list = in_list.copy()
    for r_indx,row in enumerate(in_list):
        # row_index = r_indx
        for indx,literal in enumerate(in_list):
            if literal != 3:
                continue
            if literal == 3:
                literal_index = indx
    
            return_list[r_indx][literal_index] = 1
            
            cant_reduce_to1_flag = 0
            for implct in fn_matrix:
                if not containment_check( return_list, implct):
                    print("cant be expanded to 1")
                    cant_reduce_to1_flag = 1
            if cant_reduce_to1_flag:
                return_list[r_indx][literal_index] = 3
                
            if cant_reduce_to1_flag:
                return_list[r_indx][indx] = 0    
                
                cant_reduce_to0_flag = 0
                for implct in fn_matrix:
                    if not containment_check( return_list, implct):
                        print("cant be expanded to 1")
                        cant_reduce_to0_flag = 1
                        
                if cant_reduce_to0_flag:
                    return_list[r_indx][literal_index] = 3
                
        
    return return_list


def espresso():
    global fn_matrix,expand_order
    for itter in range (3):
        expand()
        irredundent()
        expand_order = reduce_weight_matrix(expand_order)
        expand_order = reduce(expand_order)
        
espresso()

def answer_print():
    global expand_order
    op_string = ''
    for line in expand_order:
        for indx,val in enumerate(line):
            if val != 3 or val != 0:
                if val == 2:
                    if indx == 0:
                        op_string += "a'"
                elif val == 1:
                    if indx == 0:
                        op_string += 'a:'
            if val != 3 or val != 0:
                if val == 2:
                    if indx == 1:
                        op_string += "b'"
                elif val == 1:
                    if indx == 1:
                        op_string += 'b:'
            if val != 3 or val != 0:
                if val == 2:
                    if indx == 2:
                        op_string += "c'"
                elif val == 1:
                    if indx == 2:
                        op_string += 'c:'
                
        op_string += ' + '
    op_string = op_string[0:-2]
    print(op_string)
    return op_string

print("\n\nAfter appling espressso we got answer as = ")
answer_print()    
    
    
    


